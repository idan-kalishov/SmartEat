// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.1
// source: water-tracking.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type handleUnaryCall, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "watertmgmt";

export interface SaveWaterIntakeRequest {
  userId: string;
  amountLiters: number;
  /** ISO date string */
  date: string;
}

export interface SaveWaterIntakeResponse {
  success: boolean;
  waterId: string;
}

export interface GetWaterIntakeByDateRequest {
  userId: string;
  /** ISO date string */
  date: string;
}

export interface GetWaterIntakeByDateResponse {
  amountLiters: number;
  date: string;
}

export const WATERTMGMT_PACKAGE_NAME = "watertmgmt";

function createBaseSaveWaterIntakeRequest(): SaveWaterIntakeRequest {
  return { userId: "", amountLiters: 0, date: "" };
}

export const SaveWaterIntakeRequest: MessageFns<SaveWaterIntakeRequest> = {
  encode(message: SaveWaterIntakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.amountLiters !== 0) {
      writer.uint32(17).double(message.amountLiters);
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveWaterIntakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveWaterIntakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amountLiters = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSaveWaterIntakeResponse(): SaveWaterIntakeResponse {
  return { success: false, waterId: "" };
}

export const SaveWaterIntakeResponse: MessageFns<SaveWaterIntakeResponse> = {
  encode(message: SaveWaterIntakeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.waterId !== "") {
      writer.uint32(18).string(message.waterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveWaterIntakeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveWaterIntakeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.waterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetWaterIntakeByDateRequest(): GetWaterIntakeByDateRequest {
  return { userId: "", date: "" };
}

export const GetWaterIntakeByDateRequest: MessageFns<GetWaterIntakeByDateRequest> = {
  encode(message: GetWaterIntakeByDateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWaterIntakeByDateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWaterIntakeByDateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetWaterIntakeByDateResponse(): GetWaterIntakeByDateResponse {
  return { amountLiters: 0, date: "" };
}

export const GetWaterIntakeByDateResponse: MessageFns<GetWaterIntakeByDateResponse> = {
  encode(message: GetWaterIntakeByDateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amountLiters !== 0) {
      writer.uint32(9).double(message.amountLiters);
    }
    if (message.date !== "") {
      writer.uint32(18).string(message.date);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWaterIntakeByDateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWaterIntakeByDateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.amountLiters = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.date = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface WaterTrackingServiceClient {
  saveWaterIntake(request: SaveWaterIntakeRequest): Observable<SaveWaterIntakeResponse>;

  getWaterIntakeByDate(request: GetWaterIntakeByDateRequest): Observable<GetWaterIntakeByDateResponse>;
}

export interface WaterTrackingServiceController {
  saveWaterIntake(
    request: SaveWaterIntakeRequest,
  ): Promise<SaveWaterIntakeResponse> | Observable<SaveWaterIntakeResponse> | SaveWaterIntakeResponse;

  getWaterIntakeByDate(
    request: GetWaterIntakeByDateRequest,
  ): Promise<GetWaterIntakeByDateResponse> | Observable<GetWaterIntakeByDateResponse> | GetWaterIntakeByDateResponse;
}

export function WaterTrackingServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["saveWaterIntake", "getWaterIntakeByDate"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("WaterTrackingService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("WaterTrackingService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const WATER_TRACKING_SERVICE_NAME = "WaterTrackingService";

export type WaterTrackingServiceService = typeof WaterTrackingServiceService;
export const WaterTrackingServiceService = {
  saveWaterIntake: {
    path: "/watertmgmt.WaterTrackingService/SaveWaterIntake",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SaveWaterIntakeRequest) => Buffer.from(SaveWaterIntakeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SaveWaterIntakeRequest.decode(value),
    responseSerialize: (value: SaveWaterIntakeResponse) => Buffer.from(SaveWaterIntakeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SaveWaterIntakeResponse.decode(value),
  },
  getWaterIntakeByDate: {
    path: "/watertmgmt.WaterTrackingService/GetWaterIntakeByDate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWaterIntakeByDateRequest) =>
      Buffer.from(GetWaterIntakeByDateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWaterIntakeByDateRequest.decode(value),
    responseSerialize: (value: GetWaterIntakeByDateResponse) =>
      Buffer.from(GetWaterIntakeByDateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWaterIntakeByDateResponse.decode(value),
  },
} as const;

export interface WaterTrackingServiceServer extends UntypedServiceImplementation {
  saveWaterIntake: handleUnaryCall<SaveWaterIntakeRequest, SaveWaterIntakeResponse>;
  getWaterIntakeByDate: handleUnaryCall<GetWaterIntakeByDateRequest, GetWaterIntakeByDateResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
